# Problem-Solving & Programming Approach

*(Covers P5: Investigate programming languages/methods)*

- **Version 1 (Retrospective):**  
    "Reflecting on your development process, which programming challenge required the most significant pivot from your original plan?"

- **Version 2 (Hypothetical):**  
    "If tasked with implementing AI-based object recognition mid-project, how would you adapt your existing codebase?"

- **Version 3 (Trade-off Analysis):**  
    "Describe a situation where you sacrificed code elegance for performance or reliability. Was it justified?"

- **Version 4 (Comparative):**  
    "Between modularity, speed, and ease of debugging, which did you prioritize most and why?"

- **Version 5 (Failure-Driven):**  
    "Share an example where a ‘clever’ programming solution backfired. How did you recover?"

---

# System Implementation & Functionality

*(Covers P6: Program robot for task)*

- **Version 1 (Precision):**  
    "How did you ensure millimeter-level accuracy in object placement despite mechanical imperfections?"

- **Version 2 (Real-time):**  
    "Walk me through how you guaranteed consistent cycle times when sensor data arrival was unpredictable."

- **Version 3 (Error Handling):**  
    "What strategy did you use to differentiate temporary sensor glitches from permanent failures?"

- **Version 4 (Adaptation):**  
    "When testing revealed your gripper couldn’t handle a specific object type, how did you modify the program?"

- **Version 5 (Resource Limits):**  
    "Describe a memory/CPU constraint you hit and the specific code changes made to resolve it."

---

# Analysis & Optimization

*(Covers M3: Analyze offline/online programming)*

- **Version 1 (Simulation vs Real):**  
    "What did your simulation tests fail to predict about real-world operation, and how costly was the oversight?"

- **Version 2 (Benchmarking):**  
    "What metrics proved most useful for comparing offline-programmed paths vs online-adjusted ones?"

- **Version 3 (Tool Evaluation):**  
    "If budget allowed only one—a better simulator or higher-precision sensors—which would better improve your system and why?"

- **Version 4 (Iteration):**  
    "How many iterations did it take to converge on your final path planning algorithm? What drove each major change?"

- **Version 5 (Hybrid Approach):**  
    "Where did you blend offline pre-planning with real-time adjustments? What triggered the switch between modes?"

---

# Design & Testing

*(Covers D2: Design/develop/test robot program)*

- **Version 1 (Validation):**  
    "Beyond ‘it works’, how did you prove your system met all functional requirements?"

- **Version 2 (Edge Cases):**  
    "What was the most obscure edge case you tested for, and how did you discover it needed attention?"

- **Version 3 (Maintenance):**  
    "How did you structure your code to simplify troubleshooting for field technicians?"

- **Version 4 (Scalability):**  
    "If this system needed to handle 10x more objects/minute, what architectural change would be most critical?"

- **Version 5 (User Safety):**  
    "Describe how your program mitigates risks during unexpected human intervention."

---

# Professional Reflection

*(Covers all LOs holistically)*

- **Version 1 (Growth):**  
    "What technical skill did this project improve that surprised you?"

- **Version 2 (Collaboration):**  
    "How did team disagreements about implementation approaches ultimately strengthen the design?"

- **Version 3 (Ethics):**  
    "Were there any design choices you reconsidered due to safety or ethical concerns?"

- **Version 4 (Future):**  
    "What project artifact (code, docs, tests) would you prioritize improving if given two more weeks?"

- **Version 5 (Legacy):**  
    "If you could embed one lesson from this project into all future robotics work, what would it be?"

---

## Usage Example:

- Assessor selects 1 question from each group (5 total) → All LOs covered.
- Alternative: 2 from Q2 + 2 from Q4 + 1 from Q5 → Deeper P6/D2 focus.